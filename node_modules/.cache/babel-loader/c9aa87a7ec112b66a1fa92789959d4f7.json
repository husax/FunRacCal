{"ast":null,"code":"import { Fraccion, Lineal, decimal } from \"./Fracciones\";\nimport Polin from \"./Polinomio\";\nimport { FunRacional } from \"./Polinomio\"; // const Cinves = { DME: {} };\n\nclass ParCadInt {\n  constructor(c, j) {\n    this._cad = c;\n    this._jerar = j;\n  }\n\n  get cad() {\n    return this._cad;\n  }\n\n  get jerar() {\n    return this._jerar;\n  }\n\n  set jerar(j) {\n    this._jerar = j;\n  }\n\n} //Cinves.DME.InfijaAPolaca = class {\n\n\nclass InfijaAPolaca {\n  constructor(infija) {\n    // Lleva cuenta de los operadores y operandos binarios:\n    // Si es un operando lo incrementa en 1.\n    // si es un operador lo disminuye en 1.\n    // El menos unario no lo modifica. Las funciones cuentan como operadores.\n    this._balanceOp = 0; // LLeva cuenta de los pares de paréntesis:\n    // Si es paréntesis izquierdo lo incrementa en 1.\n    // si es paréntesis derecho lo decrementa en 1.\n    //\n\n    this._balancePar = 0; // sirve para distinguir el menos unario del binario\n\n    this._hayPari = false; // define el orden de prioridad de los operadores y operandos. Uno para comparar\n    // al entrar en la pila y otro para comparar al salir de la pila\n    //                  '+'     '-'     '*'     '/'    '^'      '-'unario otros unarios\n\n    this._jerarquia = [[1, 2], [1, 2], [3, 4], [3, 4], [6, 5], [8, 4], [8, 7],\n    /*           */\n    [9, 10], [11, 0], [0, 0]]; //               var y num    '('    ')'\n    // Stack de trabajo para la conversión a notación polaca\n    // this._pilaTrab= new Array();\n    // La cadena que se va a procesar\n\n    this._infija = `(${infija})@`; // si se va a procesar otra cadena con la misma instancia\n    // se hace true el booleano siguiente\n\n    this._nuevaCad = false; // Caracter asociado al separador decimal, según el país\n\n    this._sepDec = \".\"; // Posición del caracter a procesar.\n    // Si hay error indica la posición del caracter con error.\n\n    this._posicion = 0; // Después de procesar contiene la expresión en notación polaca.\n    // cada entrada del arreglo es un operador u operando\n\n    this._postFija = []; // Numero de error, si es que ocurre\n\n    this._numError = 0; // enumeración para indicar que tipos de nombres de variables son aceptables\n\n    this._tipoNomVar = {\n      Letra: 0,\n      LetrayDigitos: 1,\n      Palabra: 2,\n      PalabrayDigitos: 3\n    }; // enumeración para identificar operandos y operadores\n\n    this._tipoOper = {\n      MasBin: 0,\n      MenosBin: 1,\n      Por: 2,\n      Div: 3,\n      Potencia: 4,\n      MenosUnario: 5,\n      FuncUnaria: 6,\n      Variable: 7,\n      Numero: 7,\n      ParIzq: 8,\n      ParDer: 9,\n      MasUnario: 10 // no opera así que no le afecta la jerarquia\n\n    }; // tipo de nombres de variables aceptables vigente\n    // puede ser: una letra, Letra; una letra y dígitos, LetrayDigitos;\n    // una palabra, Palabra; una palabra y dígitos, PalabrayDigitos\n\n    this._tipoNomVarVigente = this._tipoNomVar.Letra; // contiene una lista de variables y parámetros, no los distingue,\n    // identificados al convertir la expresión.\n    // almacena pares: nombre de variable y valor\n    // de entrada contiene a PI y a e y sus valores correspondientes\n\n    this._variables = {\n      Pi: Math.PI,\n      e: Math.E\n    };\n  }\n\n  get balancePar() {\n    return this._balancePar;\n  }\n\n  get balanceOp() {\n    return this._balanceOp;\n  }\n\n  set balanceOp(valor) {\n    this._balanceOp = valor;\n  }\n\n  get hayPari() {\n    return this._hayPari;\n  }\n\n  set hayPari(bo) {\n    this._hayPari = bo;\n  }\n\n  get jerarquia() {\n    return this._jerarquia;\n  }\n\n  get sepDec() {\n    return this._sepDec;\n  }\n\n  set sepDec(cad) {\n    this._sepDec = cad;\n  }\n\n  get infija() {\n    return this._infija;\n  }\n\n  set infija(cad) {\n    this._infija = `(${cad})@`;\n    this._nuevaCad = true;\n  }\n\n  get postFija() {\n    return this._postFija;\n  }\n\n  get numError() {\n    return this._numError;\n  }\n\n  set numError(valor) {\n    this._numError = valor;\n  }\n\n  get posicion() {\n    return this._posicion;\n  }\n\n  get tipoOper() {\n    return this._tipoOper;\n  }\n\n  get tipoNomVar() {\n    return this._tipoNomVar;\n  }\n\n  get tipoNomVarVigente() {\n    return this._tipoNomVarVigente;\n  }\n\n  set tipoNomVarVigente(tipoNomVar) {\n    this._tipoNomVarVigente = tipoNomVar;\n  }\n\n  get variables() {\n    return this._variables;\n  } // Identifica un token\n  // entrega el token identificado, como un par (objeto ParCadInt:\n  // la cadena con el token\n  // el tipo de token,\n  // si el tipo es negativo es que hubo un error al identificarlo y entrega el número de error\n\n\n  leeToken() {\n    const c = this._infija[this.posicion];\n\n    if (c === \"@\") {\n      return new ParCadInt(c, 0);\n    }\n\n    if (c.isDigit() || c === this._sepDec || this.posibleNumSignado(this.posicion)) {\n      return this.identificaNum(this.posicion);\n    }\n\n    if (c.isLetter()) {\n      return this.identificaVaroFun(c);\n    }\n\n    return this.identificaOper(c);\n  } // Convierte la cadena que recibe a notación polaca inversa\n  // entrega cero si no hubo error o el número de error correspondiente.\n  // La expresión en notación polaca queda en la propiedad postFija\n\n\n  InfAPol() {\n    let par;\n    let parPila;\n    let ind;\n    let jerEnt;\n    const pilaTrab = []; // this.infija = '(' + cadena + ')@'; esto se hace en el constructor\n\n    par = this.preProcesa();\n\n    if (par.jerar < 0) {\n      this.numError = par.jerar;\n      return this.numError;\n    }\n\n    if (this._nuevaCad) {\n      this.posicion = 0;\n      this.balanceOp = 0;\n      this.balancePar = 0;\n      this.variables = {\n        Pi: Math.PI,\n        e: Math.E\n      };\n      this.postFija = [];\n    }\n\n    if (this.infija.length === 3) {\n      // solo contiene los caracteres agregados\n      this.numError = -2;\n      return this.numError; // error: no hay cadena a procesar\n    }\n\n    while (this.posicion < this.infija.length) {\n      par = this.leeToken();\n      ind = par.jerar;\n\n      if (ind < 0) {\n        this.numError = ind;\n        return this.numError;\n      }\n\n      if (ind === 10) {\n        // es un masunario , lo obvia\n        break;\n      } else if (par.cad === \"@\") {\n        if (this.balancePar > 0) {\n          this.numError = -11; // faltan paréntesis derechos\n\n          return this.numError;\n        }\n\n        return 0; // no hay error y sale por aquí numError ya es 0\n      }\n\n      par.jerar = this.jerarquia[ind][1];\n\n      if (pilaTrab.length === 0) {\n        pilaTrab.push(par);\n      } else {\n        jerEnt = this.jerarquia[ind][0];\n\n        while (pilaTrab.length > 0 && jerEnt <= pilaTrab[pilaTrab.length - 1].jerar) {\n          parPila = pilaTrab.pop();\n\n          if (parPila.jerar === jerEnt) {\n            break;\n          } else {\n            if (parPila.cad === \"-\" && parPila.jerar === 4) {\n              parPila.jerar = 7;\n            }\n\n            this.postFija.push(parPila);\n          }\n        }\n\n        if (jerEnt !== 0) {\n          pilaTrab.push(par);\n        }\n      }\n    } // parece que nunca llega a esta parte\n    // while (this.pilaTrab.length !== 0) {\n    //  this.postFija.push(this.pilaTrab.pop());\n    // }\n\n\n    return 0; // no hay error pero no sale por aqui porque cuando encuentra\n    // la @ agregada termina ahí\n  } // Funcion que se encarga de identificar un número\n  // entrega un ParCadInt\n\n\n  identificaNum(pos) {\n    const rex = /[+-]?\\d+(?:\\.\\d*)?(?:e[+-]?\\d+)?|[+-]?\\.\\d*(?:e[+-]?\\d+)?/gi;\n    rex.lastIndex = pos;\n    const partes = rex.exec(this.infija);\n    let cadNum = partes[0];\n    this._posicion = rex.lastIndex;\n    this._hayPari = false;\n    const num = Number.parseFloat(cadNum);\n\n    if (Number.isFinite(num)) {\n      if (++this._balanceOp > 1) {\n        this._posicion -= cadNum.length;\n        return new ParCadInt(cadNum, -6); // hay dos operandos seguidos, falta un operador o '('\n      }\n\n      this.prodImplicito();\n\n      if (cadNum[0] === \"+\") {\n        cadNum = cadNum.slice(1);\n      }\n\n      return new ParCadInt(cadNum, this.tipoOper.Numero); // !! sí fue un número\n    }\n\n    if (Number.isNaN(num)) {\n      // error:un punto solo (signado o no) no representa un número\n      return new ParCadInt(cadNum, -3);\n    } // error: es un número que solo se puede representar como  +/- infinito\n\n\n    return new ParCadInt(cadNum, -5);\n  } // funcion de apoyo a leeToken para ver si es el inicio de un número signado\n\n\n  posibleNumSignado(pos) {\n    const rex = /^[+-][0-9.]/;\n    const subcad = this.infija.slice(pos, pos + 2);\n\n    if (this.hayPari) {\n      return rex.test(subcad);\n    }\n\n    return false;\n  } // Se encarga de identificar el nombre de una función o bien una variable\n  // entrega un ParCadInt\n\n\n  identificaVaroFun(c) {\n    const nombresFunc = [\"sin\", \"cos\", \"tan\", \"cot\", \"sec\", \"csc\", \"sqrt\", \"abs\", \"exp\", \"ln\", \"asin\", \"acos\", \"atan\"];\n    let nom = \"\";\n    this.hayPari = false;\n    let cLocal = c;\n\n    while (cLocal.isLetter()) {\n      nom += cLocal;\n      cLocal = this.infija[++this._posicion];\n    } // this.posicion--;\n\n\n    this._balanceOp++;\n\n    if (this.balanceOp > 1) {\n      this._posicion -= nom.length;\n      return new ParCadInt(nom, -6); // error: hay dos operandos seguidos, falta un operador\n    }\n\n    const indice = nombresFunc.indexOf(nom);\n\n    if (indice !== -1) {\n      this._balanceOp--;\n\n      if (cLocal !== \"(\") {\n        // error: el argumento de la función debe ir entre paréntesis\n        return new ParCadInt(nom, -12);\n      }\n\n      return new ParCadInt(nombresFunc[indice], this.tipoOper.FuncUnaria);\n    }\n\n    return this.identificaVar(nom, cLocal);\n  } // Identifica una variable.\n  // discrimina segun las caracteristicas permitidas para los nombres de variables\n\n\n  identificaVar(nom, c) {\n    if (nom === \"Pi\" || nom === \"e\") {\n      this.prodImplicito();\n      return new ParCadInt(nom, this.tipoOper.Variable);\n    }\n\n    let nomLocal = nom;\n    let cLocal = c;\n\n    switch (this.tipoNomVarVigente) {\n      case this.tipoNomVar.Letra:\n        if (nom.length > 1) {\n          // error: Sólo acepto nombre de variables o parámetros de una letra\n          return new ParCadInt(nom, -13);\n        }\n\n        if (c.isDigit()) {\n          // error: no se aceptan nombre de variables o parámetros con dígitos.\n          // o falta un operador.\n          return new ParCadInt(nom, -14);\n        }\n\n        break;\n\n      case this.tipoNomVar.LetrayDigitos:\n        if (nom.length > 1) {\n          // error: Sólo acepto nombre de variables o parámetros de una letra,\n          // opcionalmente seguida de dígitos\n          return new ParCadInt(nom, -15);\n        }\n\n        while (c.isDigit()) {\n          nomLocal += cLocal;\n          cLocal = this.infija[++this._posicion];\n        } // this.posicion--;\n\n\n        break;\n\n      case this.tipoNomVar.Palabra:\n        if (c.isDigit()) {\n          // error: no se aceptan nombre de variables o parámetros con dígitos.\n          // o falta un operador.\n          return new ParCadInt(nom, -14);\n        }\n\n        break;\n\n      case this.tipoNomVar.PalabrayDigitos:\n        while (c.isDigit()) {\n          nomLocal += cLocal;\n          cLocal = this.infija[++this._posicion];\n        } // this.posicion--;\n\n\n        break;\n\n      default:\n        // error: ocurrio un error inesperado, al identificar una variable\n        return new ParCadInt(nom, -16);\n    } // si no existe el elemento lo crea, si ya existe, esto no agrega nada\n\n\n    this.variables[nomLocal] = 0.0;\n    this.prodImplicito();\n    return new ParCadInt(nomLocal, this.tipoOper.Variable);\n  } // Identifica un operador\n  // entrega un ParCadInt\n\n\n  identificaOper(c) {\n    const operadores = \"+-*/^#&#()\";\n    const ind = operadores.indexOf(c);\n    this._posicion++;\n\n    if (ind !== -1) {\n      switch (ind) {\n        case 0:\n          // signo +\n          if (this.hayPari) {\n            // es un mas unario, se regresa una jerarquia especial para obviarlo\n            this.hayPari = false;\n            return new ParCadInt(c, this.tipoOper.MasUnario);\n          }\n\n          if (--this._balanceOp < 0) {\n            this._posicion -= 2;\n            return new ParCadInt(c, -7); // error: hay dos operadores seguidos\n          }\n\n          return new ParCadInt(c, ind);\n        // operador binario\n        // break;\n\n        case 1:\n          // signo -\n          if (this.hayPari) {\n            this._hayPari = false;\n            return new ParCadInt(c, this.tipoOper.MenosUnario);\n          }\n\n          if (--this.balanceOp < 0) {\n            this._posicion -= 2;\n            return new ParCadInt(c, -7); // error: hay dos operadores seguidos\n          }\n\n          return new ParCadInt(c, ind);\n        // operador binario\n\n        case this.tipoOper.ParIzq:\n          this._hayPari = true;\n\n          if (this.balanceOp > 0) {\n            this._posicion -= 2;\n            return new ParCadInt(c, -9); // error: falta un operador antes del paréntesis izq\n          }\n\n          this._balancePar++;\n          return new ParCadInt(c, ind);\n        // parentésis izquierdo.\n\n        case this.tipoOper.ParDer:\n          this._hayPari = false;\n          this._balancePar--;\n\n          if (this.balanceOp === 0) {\n            this._posicion -= 2;\n            return new ParCadInt(c, -10); // error: falta un operando antes del paréntesis Der\n          }\n\n          if (this.balancePar < 0) {\n            this._posicion -= 2;\n            return new ParCadInt(c, -8); // error: paréntesis derechos de más\n          }\n\n          this.prodImplicito();\n          return new ParCadInt(c, ind);\n        // termina sin error\n\n        case this.tipoOper.Por:\n        case this.tipoOper.Div:\n        case this.tipoOper.Potencia:\n          this._hayPari = false;\n\n          if (--this._balanceOp < 0) {\n            this._posicion -= 2;\n            return new ParCadInt(c, -7); // error: hay dos operadores seguidos\n          }\n\n          return new ParCadInt(c, ind);\n        // termina sin error\n\n        default:\n          return new ParCadInt(c, -1);\n        // error: algo extraño paso hay un caracter inválido\n      }\n    }\n\n    return new ParCadInt(c, -1); // error: hay un caracter inválido\n  } // Identifica errores por aparicion de dos operadores seguidos.\n  // también reduce a un solo punto cuando hay mas de uno seguido en la cadena, sin marcar error\n  // inserta el signo * entre ) y ( contigüos\n\n\n  preProcesa() {\n    let rex = /\\.{2,}/g;\n    this._infija = this.infija.replace(rex, \".\"); // esto si acaso generara un aviso, no error\n\n    rex = /[+\\-*/^]{2,}/g; // /\\+{2,}|\\+-/g;\n\n    rex.lastIndex = 0;\n    const partes = rex.exec(this.infija);\n\n    if (rex.lastIndex > 0) {\n      return new ParCadInt(rex.lastIndex - partes[0].length, -7);\n    }\n\n    rex = /\\)\\(/g;\n    this._infija = this.infija.replace(rex, \")*(\");\n    return 0;\n  } // inserta el signo * cuando aplica\n\n\n  prodImplicito() {\n    const c = this.infija[this.posicion];\n\n    if (c.isLetter() || c === \"(\") {\n      this._infija = `${this.infija.slice(0, this.posicion)}*${this.infija.slice(this.posicion)}`;\n    }\n  } // Evalua la expresión dada en notación polaca inversa en el parámetro: postfija\n  // con los valores que tengan al momento las variables o parámetros identificadas como tales\n  // almacenadas en el parámetro: variables\n  // postFija: un arreglo de pares de tipo ParCadInt\n  // variables: un objeto JSON, donde la propiedad es el nombre de la variable y su valor es\n  // el valor de la propiedad.\n  // entrega un número como resultado o undefined si ocurre un error\n  // el número de error lo entrega en la propiedad numError\n\n\n  Eval(postFija, variables) {\n    let numero;\n    let oper1;\n    let oper2;\n    let par;\n    const pilaCalc = [];\n\n    for (let i = 0; i < postFija.length; i++) {\n      par = postFija[i];\n\n      switch (par.jerar) {\n        case 2: // operadores + o - binarios\n\n        case 4: // operadores * o /\n\n        case 5:\n          // operador ^\n          if (pilaCalc.length < 2) {\n            this.numError = -20; // error: se perdio un operando\n\n            return undefined;\n          }\n\n          oper1 = pilaCalc.pop();\n          oper2 = pilaCalc.pop();\n          pilaCalc.push(InfijaAPolaca.operaBin(oper1, oper2, par.cad));\n          break;\n\n        case 7:\n          // operador unario\n          if (pilaCalc.length === 0) {\n            this.numError = -20; // error: se perdio un operando\n\n            return undefined;\n          }\n\n          oper1 = pilaCalc.pop();\n          pilaCalc.push(InfijaAPolaca.operaUnario(oper1, par.cad));\n          break;\n\n        case 10:\n          // número o variable\n          numero = parseFloat(par.cad);\n\n          if (Number.isNaN(numero)) {\n            // entonces es una variable\n            numero = variables[par.cad];\n          }\n\n          pilaCalc.push(numero);\n          break;\n\n        default:\n          break;\n      }\n    }\n\n    if (pilaCalc.length > 1) {\n      this.numError = -21; // error: sobraron operandos al evaluar!!!\n\n      return undefined;\n    }\n\n    this.numError = 0;\n    return pilaCalc.pop();\n  } // Evalua la expresión dada en notación polaca inversa en el parámetro: postfija\n  // con los valores que tengan al momento las variables o parámetros identificadas como tales\n  // almacenadas en el parámetro: variables\n  // postFija: un arreglo de pares de tipo ParCadInt\n  // variables: un objeto JSON, donde la propiedad es el nombre de la variable y su valor es\n  // el valor de la propiedad.\n  // entrega una funcion polinomial, o una funcion racional según sea el caso\n  // el número de error lo entrega en la propiedad numError\n\n\n  EvalFuncRac(postFija) {\n    let numero;\n    let oper1;\n    let oper2;\n    let par;\n    let nomvar = Object.getOwnPropertyNames(this.variables);\n    let variable = nomvar.length > 2 ? nomvar[2] : \"\";\n    const pilaCalc = [];\n\n    for (let i = 0; i < postFija.length; i++) {\n      let pol;\n      par = postFija[i];\n\n      switch (par.jerar) {\n        case 2: // operadores + o - binarios\n\n        case 4:\n          // operadores * o /\n          if (pilaCalc.length < 2) {\n            this.numError = -20; // error: se perdio un operando\n\n            return undefined;\n          }\n\n          oper1 = pilaCalc.pop();\n          oper2 = pilaCalc.pop();\n          pilaCalc.push(InfijaAPolaca.operaBinFun(oper1, oper2, par.cad));\n          break;\n\n        case 5:\n          // operador ^\n          if (pilaCalc.length < 2) {\n            this.numError = -20; // error: se perdio un operando\n\n            return undefined;\n          }\n\n          oper1 = pilaCalc.pop();\n\n          if (!oper1.esConstante) {\n            this.num = -31; // el exponente debe ser una constante\n\n            return undefined;\n          }\n\n          oper2 = pilaCalc.pop();\n          pilaCalc.push(InfijaAPolaca.operaBinFun(oper1, oper2, par.cad));\n          break;\n\n        case 7:\n          // operador unario\n          if (pilaCalc.length === 0) {\n            this.numError = -20; // error: se perdio un operando\n\n            return undefined;\n          }\n\n          oper1 = pilaCalc.pop();\n          pilaCalc.push(oper1.ProductoPorN(-1));\n          break;\n\n        case 10:\n          // número o variable\n          numero = parseFloat(par.cad);\n\n          if (Number.isNaN(numero)) {\n            // es una variable\n            if (variable === \"\") {\n              variable = par.cad;\n            } else if (variable !== par.cad) {\n              this.numError = -30; // error: hay más de una variable en la expresión.\n\n              return undefined;\n            }\n\n            pol = Polin.Monomio(1, 1, variable);\n          } else {\n            pol = Polin.Monomio(numero, 0, variable);\n          }\n\n          pilaCalc.push(pol);\n          break;\n\n        default:\n          break;\n      }\n    }\n\n    if (pilaCalc.length > 1) {\n      this.numError = -21; // error: sobraron operandos al evaluar!!!\n\n      return undefined;\n    }\n\n    this.numError = 0;\n    return pilaCalc.pop();\n  }\n\n  static operaBinFun(opd1, opd2, operador) {\n    switch (operador) {\n      case \"+\":\n        // falta el caso funRac + Polin\n        return opd2.Suma(opd1);\n      // break;\n\n      case \"-\":\n        // falta el caso funRac - Polin\n        return opd2.Resta(opd1);\n      // break;\n\n      case \"*\":\n        return opd2.Producto(opd1);\n      // break;\n\n      case \"/\":\n        if (opd1.esConstante) {\n          return opd2.ProductoPorN(1 / opd1.coefs[0]);\n        }\n\n        if (opd2.esPolinomio && opd1.esPolinomio) {\n          return new FunRacional(opd2, opd1);\n        }\n\n        if (!opd2.esPolinomio && opd1.esPolinomio) {\n          return opd2.Cociente(new FunRacional(opd1));\n        }\n\n        if (opd2.esPolinomio && !opd1.esPolinomio) {\n          let r = new FunRacional(opd2);\n          return r.Cociente(opd1);\n        }\n\n        return opd2.Cociente(opd1);\n      // break;\n\n      case \"^\":\n        return opd2.Potencia(opd1.coefs[0]);\n      // break;\n\n      default:\n        break;\n    }\n  } // Evalua la expresión en notación polaca inversa dada en el parámetro: postfija\n  // supone una expresion sin variables y entregara como resultado\n  // un objeto de tipo fraccion como se define el Fracciones.js\n  // postFija: un arreglo de pares de tipo ParCadInt\n  // entrega un objeto de tipo fraccion o undefined si ocurre un error\n  // el número de error lo entrega en la propiedad numError\n\n\n  EvalFracciones(postFija) {\n    let numero;\n    let oper1;\n    let oper2;\n    let par;\n    const pilaCalc = [];\n\n    for (let i = 0; i < postFija.length; i++) {\n      par = postFija[i];\n\n      switch (par.jerar) {\n        case 2: // operadores + o - binarios\n\n        case 4: // operadores * o /\n\n        case 5:\n          // operador ^\n          if (pilaCalc.length < 2) {\n            this.numError = -20; // error: se perdio un operando\n\n            return undefined;\n          }\n\n          oper1 = pilaCalc.pop();\n          oper2 = pilaCalc.pop();\n          pilaCalc.push(InfijaAPolaca.operaBinFraccion(oper1, oper2, par.cad));\n          break;\n\n        case 7:\n          // operador menos unario\n          if (pilaCalc.length === 0) {\n            this.numError = -20; // error: se perdio un operando\n\n            return undefined;\n          }\n\n          oper1 = pilaCalc.pop();\n          pilaCalc.push(oper1.invAd()); //\n\n          break;\n\n        case 10:\n          // número\n          numero = parseInt(par.cad);\n\n          if (Number.isNaN(numero)) {\n            this.numError = -22; // error: se perdio un operando\n\n            return undefined;\n          }\n\n          pilaCalc.push(new Fraccion(numero));\n          break;\n\n        default:\n          break;\n      }\n    }\n\n    if (pilaCalc.length > 1) {\n      this.numError = -21; // error: sobraron operandos al evaluar!!!\n\n      return undefined;\n    }\n\n    this.numError = 0;\n    return pilaCalc.pop();\n  }\n\n  EvalLineales(postFija) {\n    let numero;\n    let oper1;\n    let oper2;\n    let par;\n    const pilaCalc = [];\n\n    for (let i = 0; i < postFija.length; i++) {\n      par = postFija[i];\n\n      switch (par.jerar) {\n        case 2:\n          // operadores + o - binarios\n          if (pilaCalc.length < 2) {\n            this.numError = -20; // error: se perdio un operando\n\n            return undefined;\n          }\n\n          oper1 = pilaCalc.pop();\n          oper2 = pilaCalc.pop();\n\n          if (oper1.isFraccion && oper2.isFraccion) {\n            pilaCalc.push(InfijaAPolaca.operaBinFraccion(oper1, oper2, par.cad));\n          } else {\n            if (oper1.isFraccion) {\n              oper1 = new Lineal(new Fraccion(0, 1), oper1);\n            } else if (oper2.isFraccion) {\n              oper2 = new Lineal(new Fraccion(0, 1), oper2);\n            } // pilaCalc.push(InfijaAPolaca.operaBinLineal(oper1, oper2, par.cad));\n\n\n            if (par.cad === \"+\") {\n              let resul = oper2.suma(oper1);\n\n              if (resul.isFraccion) {\n                pilaCalc.push(resul.ti);\n              } else {\n                pilaCalc.push(resul);\n              }\n            } else {\n              let resul = oper2.resta(oper1);\n\n              if (resul.isFraccion) {\n                pilaCalc.push(resul.ti);\n              } else {\n                pilaCalc.push(resul);\n              }\n            }\n          }\n\n          break;\n\n        case 4:\n          // operadores * o /\n          if (pilaCalc.length < 2) {\n            this.numError = -20; // error: se perdio un operando\n\n            return undefined;\n          }\n\n          oper1 = pilaCalc.pop();\n          oper2 = pilaCalc.pop(); //Caso operador \"*\"\n\n          if (par.cad === \"*\") {\n            if (oper1.isFraccion && oper2.isFraccion) {\n              pilaCalc.push(InfijaAPolaca.operaBinFraccion(oper1, oper2, par.cad));\n            } else if (oper1.isFraccion) {\n              let resul = oper2.multiesc(oper1);\n\n              if (resul.isFraccion) {\n                pilaCalc.push(resul.ti); // el coef de x es cero guarda solo la fraccion\n              } else {\n                pilaCalc.push(resul);\n              }\n            } else if (oper2.isFraccion) {\n              let resul = oper1.multiesc(oper2);\n\n              if (resul.isFraccion) {\n                pilaCalc.push(resul.ti); // el coef de x es cero guarda solo la fraccion\n              } else {\n                pilaCalc.push(resul);\n              }\n            } else {\n              this.numError = -23; // error el resultado de la operación no es un termino lineal\n\n              return undefined;\n            }\n          } //Caso operador \"/\"\n          else {\n              if (oper1.isFraccion && oper2.isFraccion) {\n                let resul = InfijaAPolaca.operaBinFraccion(oper1, oper2, par.cad);\n\n                if (resul.isFraccion) {\n                  pilaCalc.push(resul);\n                } else {\n                  this.numError = -24; // error: división entre cero. no es un número\n\n                  return undefined;\n                }\n              } else if (oper1.isFraccion) {\n                oper1 = oper1.reciproco();\n\n                if (oper1.isFraccion) {\n                  pilaCalc.push(oper2.multiesc(oper1));\n                } else {\n                  this.numError = -24; // error: división entre cero. no es un número\n\n                  return undefined;\n                }\n              } else if (oper2.isFraccion) {\n                this.numError = -23; // error el resultado de la operación no es un termino lineal\n\n                return undefined;\n              } else {\n                if (oper1.isMultiplo(oper2)) {\n                  pilaCalc.push(oper2.cx.cociente(oper1.cx));\n                } else {\n                  this.numError = -23; // error el resultado de la operación no es un termino lineal\n\n                  return undefined;\n                }\n              }\n            }\n\n          break;\n\n        case 7:\n          // operador menos unario\n          if (pilaCalc.length === 0) {\n            this.numError = -20; // error: se perdio un operando\n\n            return undefined;\n          }\n\n          oper1 = pilaCalc.pop();\n\n          if (oper1.isFraccion) {\n            pilaCalc.push(oper1.invAd());\n          } else if (oper1.isLineal) {\n            pilaCalc.push(new Lineal(oper1.cx.invAd(), oper1.invAd()));\n          } //\n\n\n          break;\n\n        case 10:\n          // número\n          numero = Number.parseFloat(par.cad);\n\n          if (Number.isNaN(numero)) {\n            pilaCalc.push(new Lineal(new Fraccion(1, 1), new Fraccion(0, 1)));\n          } else {\n            let numInt = Number.parseInt(par.cad);\n\n            if (numInt === numero) {\n              pilaCalc.push(new Fraccion(numInt));\n            } else {\n              pilaCalc.push(new Fraccion(numero, true));\n            }\n          }\n\n          break;\n\n        default:\n          break;\n      }\n    }\n\n    if (pilaCalc.length > 1) {\n      this.numError = -21; // error: sobraron operandos al evaluar!!!\n\n      return undefined;\n    }\n\n    this.numError = 0;\n    return pilaCalc.pop();\n  } // calcula las operaciones algebraicas binarias\n  // opndo1 y opndo2 estan en el orden de salida del stack\n  // por eso se operan en orden inverso cuando no es simétrica la operación\n\n\n  static operaBin(opndo1, opndo2, operador) {\n    switch (operador) {\n      case \"+\":\n        return opndo2 + opndo1;\n\n      case \"-\":\n        return opndo2 - opndo1;\n\n      case \"*\":\n        return opndo2 * opndo1;\n\n      case \"/\":\n        return opndo2 / opndo1;\n\n      case \"^\":\n        return opndo2 ** opndo1;\n\n      default:\n        return 0;\n      // es un operador inválido, a este nivel no pasa esto\n    }\n  } // calcula las operaciones aritméticas binarias como fraccion\n  // opndo1 y opndo2 estan en el orden de salida del stack\n  // por eso se operan en orden inverso cuando no es simétrica la operación\n\n\n  static operaBinFraccion(opndo1, opndo2, operador) {\n    switch (operador) {\n      case \"+\":\n        return opndo2.suma(opndo1).reduce();\n\n      case \"-\":\n        return opndo2.resta(opndo1).reduce();\n\n      case \"*\":\n        return opndo2.producto(opndo1).reduce();\n\n      case \"/\":\n        return opndo2.cociente(opndo1).reduce();\n      // case '^':\n      // se supone que el exponente es un entero\n      // return opndo2.potencia(opndo1.n);\n\n      default:\n        return 0;\n      // es un operador inválido, a este nivel no pasa esto\n    }\n  }\n\n  static IniciaErrores() {\n    InfijaAPolaca.errores[0] = \"\";\n    InfijaAPolaca.errores[1] = \"Hay un caracter inválido.\";\n    InfijaAPolaca.errores[2] = \"No hay expresión a procesar.\";\n    InfijaAPolaca.errores[3] = \"Un separador(punto) decimal, signado o no, no representa un número.\";\n    InfijaAPolaca.errores[4] = \"Un número no puede tener dos separadores(puntos) decimales.\";\n    InfijaAPolaca.errores[5] = \"Es un número pero sólo se puede representar por +/- infinito internamente.\";\n    InfijaAPolaca.errores[6] = \"Hay dos operandos seguidos, falta un operador.\";\n    InfijaAPolaca.errores[7] = \"Hay dos operadores seguidos, falta un número, una variable o una función.\";\n    InfijaAPolaca.errores[8] = \"La expresión tiene paréntesis derechos de más\";\n    InfijaAPolaca.errores[9] = \"Falta un operador antes del parentesis izquierdo.\";\n    InfijaAPolaca.errores[10] = \"Falta un operando (número o variable).\";\n    InfijaAPolaca.errores[11] = \"Faltan paréntesis derechos.\";\n    InfijaAPolaca.errores[12] = \"El argumento de una función debe ir entre paréntesis\";\n    InfijaAPolaca.errores[13] = \"Sólo se aceptan variables de una letra.\";\n    InfijaAPolaca.errores[14] = \"Después de una variable no acepto un número. Indica la operación explícitamente.\";\n    InfijaAPolaca.errores[15] = \"Las variables sólo pueden consistir de una letra opcionalmente seguida de dígitos.\";\n    InfijaAPolaca.errores[16] = \"Ocurrio un error inesperado al identificar una variable!!!\";\n    InfijaAPolaca.errores[17] = 'No acepto parámetros o más de una variable, denotada por la letra \"x\".';\n    InfijaAPolaca.errores[18] = 'Sólo acepto la variable \"x\".';\n    InfijaAPolaca.errores[19] = \"\";\n    InfijaAPolaca.errores[20] = \"Se perdió un operando\";\n    InfijaAPolaca.errores[21] = \"Sobraron operandos al evaluar\";\n    InfijaAPolaca.errores[22] = \"Esperaba un número entero\";\n    InfijaAPolaca.errores[23] = \"El resultado de la operación no es un término lineal\";\n    InfijaAPolaca.errores[24] = \"División entre cero. el resultado no es un número\";\n    InfijaAPolaca.errores[25] = 'Falta el signo igual \"=\" para que sea una ecuación';\n    InfijaAPolaca.errores[26] = \"Debe haber una expresión antes del signo =\";\n    InfijaAPolaca.errores[27] = \"Debe haber una expresión después del signo =\";\n    InfijaAPolaca.errores[28] = \"NO puede haber más de un igual en una ecuación\";\n  }\n\n} // Extiende String para identificar si una cadena con un caracter es un Dígito\n\n\nInfijaAPolaca.errores = [];\n\nString.prototype.isDigit = function () {\n  return this.length === 1 && /^\\d/.test(this);\n}; // Extiende String para identificar si una cadena con un caracter es una letra\n\n\nString.prototype.isLetter = function () {\n  return this.length === 1 && /^[A-Za-z]/.test(this);\n};\n\nexport default InfijaAPolaca;","map":{"version":3,"sources":["D:/repos/calcvisual/calcvisual-react-frontend/src/InfAPolInvCls.js"],"names":["Fraccion","Lineal","decimal","Polin","FunRacional","ParCadInt","constructor","c","j","_cad","_jerar","cad","jerar","InfijaAPolaca","infija","_balanceOp","_balancePar","_hayPari","_jerarquia","_infija","_nuevaCad","_sepDec","_posicion","_postFija","_numError","_tipoNomVar","Letra","LetrayDigitos","Palabra","PalabrayDigitos","_tipoOper","MasBin","MenosBin","Por","Div","Potencia","MenosUnario","FuncUnaria","Variable","Numero","ParIzq","ParDer","MasUnario","_tipoNomVarVigente","_variables","Pi","Math","PI","e","E","balancePar","balanceOp","valor","hayPari","bo","jerarquia","sepDec","postFija","numError","posicion","tipoOper","tipoNomVar","tipoNomVarVigente","variables","leeToken","isDigit","posibleNumSignado","identificaNum","isLetter","identificaVaroFun","identificaOper","InfAPol","par","parPila","ind","jerEnt","pilaTrab","preProcesa","length","push","pop","pos","rex","lastIndex","partes","exec","cadNum","num","Number","parseFloat","isFinite","prodImplicito","slice","isNaN","subcad","test","nombresFunc","nom","cLocal","indice","indexOf","identificaVar","nomLocal","operadores","replace","Eval","numero","oper1","oper2","pilaCalc","i","undefined","operaBin","operaUnario","EvalFuncRac","nomvar","Object","getOwnPropertyNames","variable","pol","operaBinFun","esConstante","ProductoPorN","Monomio","opd1","opd2","operador","Suma","Resta","Producto","coefs","esPolinomio","Cociente","r","EvalFracciones","operaBinFraccion","invAd","parseInt","EvalLineales","isFraccion","resul","suma","ti","resta","multiesc","reciproco","isMultiplo","cx","cociente","isLineal","numInt","opndo1","opndo2","reduce","producto","IniciaErrores","errores","String","prototype"],"mappings":"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","sourcesContent":["import { Fraccion, Lineal, decimal } from \"./Fracciones\";\r\nimport Polin from \"./Polinomio\";\r\nimport { FunRacional } from \"./Polinomio\";\r\n// const Cinves = { DME: {} };\r\nclass ParCadInt {\r\n  constructor(c, j) {\r\n    this._cad = c;\r\n    this._jerar = j;\r\n  }\r\n\r\n  get cad() {\r\n    return this._cad;\r\n  }\r\n\r\n  get jerar() {\r\n    return this._jerar;\r\n  }\r\n\r\n  set jerar(j) {\r\n    this._jerar = j;\r\n  }\r\n}\r\n\r\n//Cinves.DME.InfijaAPolaca = class {\r\nclass InfijaAPolaca {\r\n  constructor(infija) {\r\n    // Lleva cuenta de los operadores y operandos binarios:\r\n    // Si es un operando lo incrementa en 1.\r\n    // si es un operador lo disminuye en 1.\r\n    // El menos unario no lo modifica. Las funciones cuentan como operadores.\r\n    this._balanceOp = 0;\r\n\r\n    // LLeva cuenta de los pares de paréntesis:\r\n    // Si es paréntesis izquierdo lo incrementa en 1.\r\n    // si es paréntesis derecho lo decrementa en 1.\r\n    //\r\n    this._balancePar = 0;\r\n\r\n    // sirve para distinguir el menos unario del binario\r\n    this._hayPari = false;\r\n\r\n    // define el orden de prioridad de los operadores y operandos. Uno para comparar\r\n    // al entrar en la pila y otro para comparar al salir de la pila\r\n    //                  '+'     '-'     '*'     '/'    '^'      '-'unario otros unarios\r\n    this._jerarquia = [\r\n      [1, 2],\r\n      [1, 2],\r\n      [3, 4],\r\n      [3, 4],\r\n      [6, 5],\r\n      [8, 4],\r\n      [8, 7],\r\n      /*           */ [9, 10],\r\n      [11, 0],\r\n      [0, 0],\r\n    ];\r\n    //               var y num    '('    ')'\r\n\r\n    // Stack de trabajo para la conversión a notación polaca\r\n    // this._pilaTrab= new Array();\r\n\r\n    // La cadena que se va a procesar\r\n    this._infija = `(${infija})@`;\r\n\r\n    // si se va a procesar otra cadena con la misma instancia\r\n    // se hace true el booleano siguiente\r\n    this._nuevaCad = false;\r\n\r\n    // Caracter asociado al separador decimal, según el país\r\n    this._sepDec = \".\";\r\n\r\n    // Posición del caracter a procesar.\r\n    // Si hay error indica la posición del caracter con error.\r\n    this._posicion = 0;\r\n\r\n    // Después de procesar contiene la expresión en notación polaca.\r\n    // cada entrada del arreglo es un operador u operando\r\n    this._postFija = [];\r\n\r\n    // Numero de error, si es que ocurre\r\n    this._numError = 0;\r\n\r\n    // enumeración para indicar que tipos de nombres de variables son aceptables\r\n    this._tipoNomVar = {\r\n      Letra: 0,\r\n      LetrayDigitos: 1,\r\n      Palabra: 2,\r\n      PalabrayDigitos: 3,\r\n    };\r\n\r\n    // enumeración para identificar operandos y operadores\r\n    this._tipoOper = {\r\n      MasBin: 0,\r\n      MenosBin: 1,\r\n      Por: 2,\r\n      Div: 3,\r\n      Potencia: 4,\r\n      MenosUnario: 5,\r\n      FuncUnaria: 6,\r\n      Variable: 7,\r\n      Numero: 7,\r\n      ParIzq: 8,\r\n      ParDer: 9,\r\n      MasUnario: 10, // no opera así que no le afecta la jerarquia\r\n    };\r\n\r\n    // tipo de nombres de variables aceptables vigente\r\n    // puede ser: una letra, Letra; una letra y dígitos, LetrayDigitos;\r\n    // una palabra, Palabra; una palabra y dígitos, PalabrayDigitos\r\n    this._tipoNomVarVigente = this._tipoNomVar.Letra;\r\n\r\n    // contiene una lista de variables y parámetros, no los distingue,\r\n    // identificados al convertir la expresión.\r\n    // almacena pares: nombre de variable y valor\r\n    // de entrada contiene a PI y a e y sus valores correspondientes\r\n    this._variables = {\r\n      Pi: Math.PI,\r\n      e: Math.E,\r\n    };\r\n  }\r\n\r\n  static errores = [];\r\n\r\n  get balancePar() {\r\n    return this._balancePar;\r\n  }\r\n\r\n  get balanceOp() {\r\n    return this._balanceOp;\r\n  }\r\n\r\n  set balanceOp(valor) {\r\n    this._balanceOp = valor;\r\n  }\r\n\r\n  get hayPari() {\r\n    return this._hayPari;\r\n  }\r\n\r\n  set hayPari(bo) {\r\n    this._hayPari = bo;\r\n  }\r\n\r\n  get jerarquia() {\r\n    return this._jerarquia;\r\n  }\r\n\r\n  get sepDec() {\r\n    return this._sepDec;\r\n  }\r\n\r\n  set sepDec(cad) {\r\n    this._sepDec = cad;\r\n  }\r\n\r\n  get infija() {\r\n    return this._infija;\r\n  }\r\n\r\n  set infija(cad) {\r\n    this._infija = `(${cad})@`;\r\n    this._nuevaCad = true;\r\n  }\r\n\r\n  get postFija() {\r\n    return this._postFija;\r\n  }\r\n\r\n  get numError() {\r\n    return this._numError;\r\n  }\r\n\r\n  set numError(valor) {\r\n    this._numError = valor;\r\n  }\r\n\r\n  get posicion() {\r\n    return this._posicion;\r\n  }\r\n\r\n  get tipoOper() {\r\n    return this._tipoOper;\r\n  }\r\n  get tipoNomVar() {\r\n    return this._tipoNomVar;\r\n  }\r\n\r\n  get tipoNomVarVigente() {\r\n    return this._tipoNomVarVigente;\r\n  }\r\n\r\n  set tipoNomVarVigente(tipoNomVar) {\r\n    this._tipoNomVarVigente = tipoNomVar;\r\n  }\r\n\r\n  get variables() {\r\n    return this._variables;\r\n  }\r\n\r\n  // Identifica un token\r\n  // entrega el token identificado, como un par (objeto ParCadInt:\r\n  // la cadena con el token\r\n  // el tipo de token,\r\n  // si el tipo es negativo es que hubo un error al identificarlo y entrega el número de error\r\n  leeToken() {\r\n    const c = this._infija[this.posicion];\r\n    if (c === \"@\") {\r\n      return new ParCadInt(c, 0);\r\n    }\r\n    if (\r\n      c.isDigit() ||\r\n      c === this._sepDec ||\r\n      this.posibleNumSignado(this.posicion)\r\n    ) {\r\n      return this.identificaNum(this.posicion);\r\n    }\r\n    if (c.isLetter()) {\r\n      return this.identificaVaroFun(c);\r\n    }\r\n    return this.identificaOper(c);\r\n  }\r\n\r\n  // Convierte la cadena que recibe a notación polaca inversa\r\n  // entrega cero si no hubo error o el número de error correspondiente.\r\n  // La expresión en notación polaca queda en la propiedad postFija\r\n  InfAPol() {\r\n    let par;\r\n    let parPila;\r\n    let ind;\r\n    let jerEnt;\r\n\r\n    const pilaTrab = [];\r\n    // this.infija = '(' + cadena + ')@'; esto se hace en el constructor\r\n    par = this.preProcesa();\r\n    if (par.jerar < 0) {\r\n      this.numError = par.jerar;\r\n      return this.numError;\r\n    }\r\n    if (this._nuevaCad) {\r\n      this.posicion = 0;\r\n      this.balanceOp = 0;\r\n      this.balancePar = 0;\r\n      this.variables = {\r\n        Pi: Math.PI,\r\n        e: Math.E,\r\n      };\r\n      this.postFija = [];\r\n    }\r\n    if (this.infija.length === 3) {\r\n      // solo contiene los caracteres agregados\r\n      this.numError = -2;\r\n      return this.numError; // error: no hay cadena a procesar\r\n    }\r\n    while (this.posicion < this.infija.length) {\r\n      par = this.leeToken();\r\n      ind = par.jerar;\r\n      if (ind < 0) {\r\n        this.numError = ind;\r\n        return this.numError;\r\n      }\r\n      if (ind === 10) {\r\n        // es un masunario , lo obvia\r\n        break;\r\n      } else if (par.cad === \"@\") {\r\n        if (this.balancePar > 0) {\r\n          this.numError = -11; // faltan paréntesis derechos\r\n          return this.numError;\r\n        }\r\n        return 0; // no hay error y sale por aquí numError ya es 0\r\n      }\r\n      par.jerar = this.jerarquia[ind][1];\r\n      if (pilaTrab.length === 0) {\r\n        pilaTrab.push(par);\r\n      } else {\r\n        jerEnt = this.jerarquia[ind][0];\r\n        while (\r\n          pilaTrab.length > 0 &&\r\n          jerEnt <= pilaTrab[pilaTrab.length - 1].jerar\r\n        ) {\r\n          parPila = pilaTrab.pop();\r\n          if (parPila.jerar === jerEnt) {\r\n            break;\r\n          } else {\r\n            if (parPila.cad === \"-\" && parPila.jerar === 4) {\r\n              parPila.jerar = 7;\r\n            }\r\n            this.postFija.push(parPila);\r\n          }\r\n        }\r\n        if (jerEnt !== 0) {\r\n          pilaTrab.push(par);\r\n        }\r\n      }\r\n    }\r\n    // parece que nunca llega a esta parte\r\n    // while (this.pilaTrab.length !== 0) {\r\n    //  this.postFija.push(this.pilaTrab.pop());\r\n    // }\r\n    return 0; // no hay error pero no sale por aqui porque cuando encuentra\r\n    // la @ agregada termina ahí\r\n  }\r\n\r\n  // Funcion que se encarga de identificar un número\r\n  // entrega un ParCadInt\r\n  identificaNum(pos) {\r\n    const rex = /[+-]?\\d+(?:\\.\\d*)?(?:e[+-]?\\d+)?|[+-]?\\.\\d*(?:e[+-]?\\d+)?/gi;\r\n    rex.lastIndex = pos;\r\n    const partes = rex.exec(this.infija);\r\n    let cadNum = partes[0];\r\n    this._posicion = rex.lastIndex;\r\n    this._hayPari = false;\r\n    const num = Number.parseFloat(cadNum);\r\n    if (Number.isFinite(num)) {\r\n      if (++this._balanceOp > 1) {\r\n        this._posicion -= cadNum.length;\r\n        return new ParCadInt(cadNum, -6); // hay dos operandos seguidos, falta un operador o '('\r\n      }\r\n      this.prodImplicito();\r\n      if (cadNum[0] === \"+\") {\r\n        cadNum = cadNum.slice(1);\r\n      }\r\n      return new ParCadInt(cadNum, this.tipoOper.Numero); // !! sí fue un número\r\n    }\r\n    if (Number.isNaN(num)) {\r\n      // error:un punto solo (signado o no) no representa un número\r\n      return new ParCadInt(cadNum, -3);\r\n    }\r\n    // error: es un número que solo se puede representar como  +/- infinito\r\n    return new ParCadInt(cadNum, -5);\r\n  }\r\n\r\n  // funcion de apoyo a leeToken para ver si es el inicio de un número signado\r\n  posibleNumSignado(pos) {\r\n    const rex = /^[+-][0-9.]/;\r\n    const subcad = this.infija.slice(pos, pos + 2);\r\n    if (this.hayPari) {\r\n      return rex.test(subcad);\r\n    }\r\n    return false;\r\n  }\r\n\r\n  // Se encarga de identificar el nombre de una función o bien una variable\r\n  // entrega un ParCadInt\r\n  identificaVaroFun(c) {\r\n    const nombresFunc = [\r\n      \"sin\",\r\n      \"cos\",\r\n      \"tan\",\r\n      \"cot\",\r\n      \"sec\",\r\n      \"csc\",\r\n      \"sqrt\",\r\n      \"abs\",\r\n      \"exp\",\r\n      \"ln\",\r\n      \"asin\",\r\n      \"acos\",\r\n      \"atan\",\r\n    ];\r\n    let nom = \"\";\r\n    this.hayPari = false;\r\n    let cLocal = c;\r\n    while (cLocal.isLetter()) {\r\n      nom += cLocal;\r\n      cLocal = this.infija[++this._posicion];\r\n    }\r\n    // this.posicion--;\r\n    this._balanceOp++;\r\n    if (this.balanceOp > 1) {\r\n      this._posicion -= nom.length;\r\n      return new ParCadInt(nom, -6); // error: hay dos operandos seguidos, falta un operador\r\n    }\r\n    const indice = nombresFunc.indexOf(nom);\r\n    if (indice !== -1) {\r\n      this._balanceOp--;\r\n      if (cLocal !== \"(\") {\r\n        // error: el argumento de la función debe ir entre paréntesis\r\n        return new ParCadInt(nom, -12);\r\n      }\r\n      return new ParCadInt(nombresFunc[indice], this.tipoOper.FuncUnaria);\r\n    }\r\n    return this.identificaVar(nom, cLocal);\r\n  }\r\n\r\n  // Identifica una variable.\r\n  // discrimina segun las caracteristicas permitidas para los nombres de variables\r\n  identificaVar(nom, c) {\r\n    if (nom === \"Pi\" || nom === \"e\") {\r\n      this.prodImplicito();\r\n      return new ParCadInt(nom, this.tipoOper.Variable);\r\n    }\r\n    let nomLocal = nom;\r\n    let cLocal = c;\r\n    switch (this.tipoNomVarVigente) {\r\n      case this.tipoNomVar.Letra:\r\n        if (nom.length > 1) {\r\n          // error: Sólo acepto nombre de variables o parámetros de una letra\r\n          return new ParCadInt(nom, -13);\r\n        }\r\n        if (c.isDigit()) {\r\n          // error: no se aceptan nombre de variables o parámetros con dígitos.\r\n          // o falta un operador.\r\n          return new ParCadInt(nom, -14);\r\n        }\r\n        break;\r\n      case this.tipoNomVar.LetrayDigitos:\r\n        if (nom.length > 1) {\r\n          // error: Sólo acepto nombre de variables o parámetros de una letra,\r\n          // opcionalmente seguida de dígitos\r\n          return new ParCadInt(nom, -15);\r\n        }\r\n        while (c.isDigit()) {\r\n          nomLocal += cLocal;\r\n          cLocal = this.infija[++this._posicion];\r\n        }\r\n        // this.posicion--;\r\n        break;\r\n      case this.tipoNomVar.Palabra:\r\n        if (c.isDigit()) {\r\n          // error: no se aceptan nombre de variables o parámetros con dígitos.\r\n          // o falta un operador.\r\n          return new ParCadInt(nom, -14);\r\n        }\r\n        break;\r\n      case this.tipoNomVar.PalabrayDigitos:\r\n        while (c.isDigit()) {\r\n          nomLocal += cLocal;\r\n          cLocal = this.infija[++this._posicion];\r\n        }\r\n        // this.posicion--;\r\n        break;\r\n      default:\r\n        // error: ocurrio un error inesperado, al identificar una variable\r\n        return new ParCadInt(nom, -16);\r\n    }\r\n    // si no existe el elemento lo crea, si ya existe, esto no agrega nada\r\n    this.variables[nomLocal] = 0.0;\r\n    this.prodImplicito();\r\n    return new ParCadInt(nomLocal, this.tipoOper.Variable);\r\n  }\r\n\r\n  // Identifica un operador\r\n  // entrega un ParCadInt\r\n  identificaOper(c) {\r\n    const operadores = \"+-*/^#&#()\";\r\n    const ind = operadores.indexOf(c);\r\n    this._posicion++;\r\n    if (ind !== -1) {\r\n      switch (ind) {\r\n        case 0: // signo +\r\n          if (this.hayPari) {\r\n            // es un mas unario, se regresa una jerarquia especial para obviarlo\r\n            this.hayPari = false;\r\n            return new ParCadInt(c, this.tipoOper.MasUnario);\r\n          }\r\n          if (--this._balanceOp < 0) {\r\n            this._posicion -= 2;\r\n            return new ParCadInt(c, -7); // error: hay dos operadores seguidos\r\n          }\r\n          return new ParCadInt(c, ind); // operador binario\r\n        // break;\r\n        case 1: // signo -\r\n          if (this.hayPari) {\r\n            this._hayPari = false;\r\n            return new ParCadInt(c, this.tipoOper.MenosUnario);\r\n          }\r\n          if (--this.balanceOp < 0) {\r\n            this._posicion -= 2;\r\n            return new ParCadInt(c, -7); // error: hay dos operadores seguidos\r\n          }\r\n          return new ParCadInt(c, ind); // operador binario\r\n        case this.tipoOper.ParIzq:\r\n          this._hayPari = true;\r\n          if (this.balanceOp > 0) {\r\n            this._posicion -= 2;\r\n            return new ParCadInt(c, -9); // error: falta un operador antes del paréntesis izq\r\n          }\r\n          this._balancePar++;\r\n          return new ParCadInt(c, ind); // parentésis izquierdo.\r\n        case this.tipoOper.ParDer:\r\n          this._hayPari = false;\r\n          this._balancePar--;\r\n          if (this.balanceOp === 0) {\r\n            this._posicion -= 2;\r\n            return new ParCadInt(c, -10); // error: falta un operando antes del paréntesis Der\r\n          }\r\n          if (this.balancePar < 0) {\r\n            this._posicion -= 2;\r\n            return new ParCadInt(c, -8); // error: paréntesis derechos de más\r\n          }\r\n          this.prodImplicito();\r\n          return new ParCadInt(c, ind); // termina sin error\r\n        case this.tipoOper.Por:\r\n        case this.tipoOper.Div:\r\n        case this.tipoOper.Potencia:\r\n          this._hayPari = false;\r\n          if (--this._balanceOp < 0) {\r\n            this._posicion -= 2;\r\n            return new ParCadInt(c, -7); // error: hay dos operadores seguidos\r\n          }\r\n          return new ParCadInt(c, ind); // termina sin error\r\n        default:\r\n          return new ParCadInt(c, -1); // error: algo extraño paso hay un caracter inválido\r\n      }\r\n    }\r\n    return new ParCadInt(c, -1); // error: hay un caracter inválido\r\n  }\r\n\r\n  // Identifica errores por aparicion de dos operadores seguidos.\r\n  // también reduce a un solo punto cuando hay mas de uno seguido en la cadena, sin marcar error\r\n  // inserta el signo * entre ) y ( contigüos\r\n  preProcesa() {\r\n    let rex = /\\.{2,}/g;\r\n    this._infija = this.infija.replace(rex, \".\"); // esto si acaso generara un aviso, no error\r\n    rex = /[+\\-*/^]{2,}/g; // /\\+{2,}|\\+-/g;\r\n    rex.lastIndex = 0;\r\n    const partes = rex.exec(this.infija);\r\n    if (rex.lastIndex > 0) {\r\n      return new ParCadInt(rex.lastIndex - partes[0].length, -7);\r\n    }\r\n    rex = /\\)\\(/g;\r\n    this._infija = this.infija.replace(rex, \")*(\");\r\n    return 0;\r\n  }\r\n\r\n  // inserta el signo * cuando aplica\r\n  prodImplicito() {\r\n    const c = this.infija[this.posicion];\r\n    if (c.isLetter() || c === \"(\") {\r\n      this._infija = `${this.infija.slice(\r\n        0,\r\n        this.posicion\r\n      )}*${this.infija.slice(this.posicion)}`;\r\n    }\r\n  }\r\n\r\n  // Evalua la expresión dada en notación polaca inversa en el parámetro: postfija\r\n  // con los valores que tengan al momento las variables o parámetros identificadas como tales\r\n  // almacenadas en el parámetro: variables\r\n  // postFija: un arreglo de pares de tipo ParCadInt\r\n  // variables: un objeto JSON, donde la propiedad es el nombre de la variable y su valor es\r\n  // el valor de la propiedad.\r\n  // entrega un número como resultado o undefined si ocurre un error\r\n  // el número de error lo entrega en la propiedad numError\r\n  Eval(postFija, variables) {\r\n    let numero;\r\n    let oper1;\r\n    let oper2;\r\n    let par;\r\n    const pilaCalc = [];\r\n    for (let i = 0; i < postFija.length; i++) {\r\n      par = postFija[i];\r\n      switch (par.jerar) {\r\n        case 2: // operadores + o - binarios\r\n        case 4: // operadores * o /\r\n        case 5: // operador ^\r\n          if (pilaCalc.length < 2) {\r\n            this.numError = -20; // error: se perdio un operando\r\n            return undefined;\r\n          }\r\n          oper1 = pilaCalc.pop();\r\n          oper2 = pilaCalc.pop();\r\n          pilaCalc.push(InfijaAPolaca.operaBin(oper1, oper2, par.cad));\r\n          break;\r\n        case 7: // operador unario\r\n          if (pilaCalc.length === 0) {\r\n            this.numError = -20; // error: se perdio un operando\r\n            return undefined;\r\n          }\r\n          oper1 = pilaCalc.pop();\r\n          pilaCalc.push(InfijaAPolaca.operaUnario(oper1, par.cad));\r\n          break;\r\n        case 10: // número o variable\r\n          numero = parseFloat(par.cad);\r\n          if (Number.isNaN(numero)) {\r\n            // entonces es una variable\r\n            numero = variables[par.cad];\r\n          }\r\n          pilaCalc.push(numero);\r\n          break;\r\n        default:\r\n          break;\r\n      }\r\n    }\r\n    if (pilaCalc.length > 1) {\r\n      this.numError = -21; // error: sobraron operandos al evaluar!!!\r\n      return undefined;\r\n    }\r\n    this.numError = 0;\r\n    return pilaCalc.pop();\r\n  }\r\n\r\n  // Evalua la expresión dada en notación polaca inversa en el parámetro: postfija\r\n  // con los valores que tengan al momento las variables o parámetros identificadas como tales\r\n  // almacenadas en el parámetro: variables\r\n  // postFija: un arreglo de pares de tipo ParCadInt\r\n  // variables: un objeto JSON, donde la propiedad es el nombre de la variable y su valor es\r\n  // el valor de la propiedad.\r\n  // entrega una funcion polinomial, o una funcion racional según sea el caso\r\n  // el número de error lo entrega en la propiedad numError\r\n  EvalFuncRac(postFija) {\r\n    let numero;\r\n    let oper1;\r\n    let oper2;\r\n    let par;\r\n    let nomvar = Object.getOwnPropertyNames(this.variables);\r\n    let variable = nomvar.length > 2 ? nomvar[2] : \"\";\r\n    const pilaCalc = [];\r\n    for (let i = 0; i < postFija.length; i++) {\r\n      let pol;\r\n      par = postFija[i];\r\n      switch (par.jerar) {\r\n        case 2: // operadores + o - binarios\r\n        case 4: // operadores * o /\r\n          if (pilaCalc.length < 2) {\r\n            this.numError = -20; // error: se perdio un operando\r\n            return undefined;\r\n          }\r\n          oper1 = pilaCalc.pop();\r\n          oper2 = pilaCalc.pop();\r\n          pilaCalc.push(InfijaAPolaca.operaBinFun(oper1, oper2, par.cad));\r\n          break;\r\n        case 5: // operador ^\r\n          if (pilaCalc.length < 2) {\r\n            this.numError = -20; // error: se perdio un operando\r\n            return undefined;\r\n          }\r\n          oper1 = pilaCalc.pop();\r\n          if (!oper1.esConstante) {\r\n            this.num = -31; // el exponente debe ser una constante\r\n            return undefined;\r\n          }\r\n          oper2 = pilaCalc.pop();\r\n          pilaCalc.push(InfijaAPolaca.operaBinFun(oper1, oper2, par.cad));\r\n          break;\r\n        case 7: // operador unario\r\n          if (pilaCalc.length === 0) {\r\n            this.numError = -20; // error: se perdio un operando\r\n            return undefined;\r\n          }\r\n          oper1 = pilaCalc.pop();\r\n          pilaCalc.push(oper1.ProductoPorN(-1));\r\n          break;\r\n        case 10: // número o variable\r\n          numero = parseFloat(par.cad);\r\n          if (Number.isNaN(numero)) {\r\n            // es una variable\r\n            if (variable === \"\") {\r\n              variable = par.cad;\r\n            } else if (variable !== par.cad) {\r\n              this.numError = -30; // error: hay más de una variable en la expresión.\r\n              return undefined;\r\n            }\r\n            pol = Polin.Monomio(1, 1, variable);\r\n          } else {\r\n            pol = Polin.Monomio(numero, 0, variable);\r\n          }\r\n          pilaCalc.push(pol);\r\n          break;\r\n        default:\r\n          break;\r\n      }\r\n    }\r\n    if (pilaCalc.length > 1) {\r\n      this.numError = -21; // error: sobraron operandos al evaluar!!!\r\n      return undefined;\r\n    }\r\n    this.numError = 0;\r\n    return pilaCalc.pop();\r\n  }\r\n\r\n  static operaBinFun(opd1, opd2, operador) {\r\n    switch (operador) {\r\n      case \"+\": // falta el caso funRac + Polin\r\n        return opd2.Suma(opd1);\r\n      // break;\r\n      case \"-\": // falta el caso funRac - Polin\r\n        return opd2.Resta(opd1);\r\n      // break;\r\n      case \"*\":\r\n        return opd2.Producto(opd1);\r\n      // break;\r\n      case \"/\":\r\n        if (opd1.esConstante) {\r\n          return opd2.ProductoPorN(1 / opd1.coefs[0]);\r\n        }\r\n        if (opd2.esPolinomio && opd1.esPolinomio) {\r\n          return new FunRacional(opd2, opd1);\r\n        }\r\n        if (!opd2.esPolinomio && opd1.esPolinomio) {\r\n          return opd2.Cociente(new FunRacional(opd1));\r\n        }\r\n        if (opd2.esPolinomio && !opd1.esPolinomio) {\r\n          let r = new FunRacional(opd2);\r\n          return r.Cociente(opd1);\r\n        }\r\n        return opd2.Cociente(opd1);\r\n      // break;\r\n      case \"^\":\r\n        return opd2.Potencia(opd1.coefs[0]);\r\n      // break;\r\n      default:\r\n        break;\r\n    }\r\n  }\r\n\r\n  // Evalua la expresión en notación polaca inversa dada en el parámetro: postfija\r\n  // supone una expresion sin variables y entregara como resultado\r\n  // un objeto de tipo fraccion como se define el Fracciones.js\r\n  // postFija: un arreglo de pares de tipo ParCadInt\r\n  // entrega un objeto de tipo fraccion o undefined si ocurre un error\r\n  // el número de error lo entrega en la propiedad numError\r\n  EvalFracciones(postFija) {\r\n    let numero;\r\n    let oper1;\r\n    let oper2;\r\n    let par;\r\n    const pilaCalc = [];\r\n    for (let i = 0; i < postFija.length; i++) {\r\n      par = postFija[i];\r\n      switch (par.jerar) {\r\n        case 2: // operadores + o - binarios\r\n        case 4: // operadores * o /\r\n        case 5: // operador ^\r\n          if (pilaCalc.length < 2) {\r\n            this.numError = -20; // error: se perdio un operando\r\n            return undefined;\r\n          }\r\n          oper1 = pilaCalc.pop();\r\n          oper2 = pilaCalc.pop();\r\n          pilaCalc.push(InfijaAPolaca.operaBinFraccion(oper1, oper2, par.cad));\r\n          break;\r\n        case 7: // operador menos unario\r\n          if (pilaCalc.length === 0) {\r\n            this.numError = -20; // error: se perdio un operando\r\n            return undefined;\r\n          }\r\n          oper1 = pilaCalc.pop();\r\n          pilaCalc.push(oper1.invAd()); //\r\n          break;\r\n        case 10: // número\r\n          numero = parseInt(par.cad);\r\n          if (Number.isNaN(numero)) {\r\n            this.numError = -22; // error: se perdio un operando\r\n            return undefined;\r\n          }\r\n          pilaCalc.push(new Fraccion(numero));\r\n          break;\r\n        default:\r\n          break;\r\n      }\r\n    }\r\n    if (pilaCalc.length > 1) {\r\n      this.numError = -21; // error: sobraron operandos al evaluar!!!\r\n      return undefined;\r\n    }\r\n    this.numError = 0;\r\n    return pilaCalc.pop();\r\n  }\r\n\r\n  EvalLineales(postFija) {\r\n    let numero;\r\n    let oper1;\r\n    let oper2;\r\n    let par;\r\n    const pilaCalc = [];\r\n    for (let i = 0; i < postFija.length; i++) {\r\n      par = postFija[i];\r\n      switch (par.jerar) {\r\n        case 2: // operadores + o - binarios\r\n          if (pilaCalc.length < 2) {\r\n            this.numError = -20; // error: se perdio un operando\r\n            return undefined;\r\n          }\r\n          oper1 = pilaCalc.pop();\r\n          oper2 = pilaCalc.pop();\r\n\r\n          if (oper1.isFraccion && oper2.isFraccion) {\r\n            pilaCalc.push(\r\n              InfijaAPolaca.operaBinFraccion(oper1, oper2, par.cad)\r\n            );\r\n          } else {\r\n            if (oper1.isFraccion) {\r\n              oper1 = new Lineal(new Fraccion(0, 1), oper1);\r\n            } else if (oper2.isFraccion) {\r\n              oper2 = new Lineal(new Fraccion(0, 1), oper2);\r\n            }\r\n\r\n            // pilaCalc.push(InfijaAPolaca.operaBinLineal(oper1, oper2, par.cad));\r\n\r\n            if (par.cad === \"+\") {\r\n              let resul = oper2.suma(oper1);\r\n              if (resul.isFraccion) {\r\n                pilaCalc.push(resul.ti);\r\n              } else {\r\n                pilaCalc.push(resul);\r\n              }\r\n            } else {\r\n              let resul = oper2.resta(oper1);\r\n              if (resul.isFraccion) {\r\n                pilaCalc.push(resul.ti);\r\n              } else {\r\n                pilaCalc.push(resul);\r\n              }\r\n            }\r\n          }\r\n\r\n          break;\r\n\r\n        case 4: // operadores * o /\r\n          if (pilaCalc.length < 2) {\r\n            this.numError = -20; // error: se perdio un operando\r\n            return undefined;\r\n          }\r\n\r\n          oper1 = pilaCalc.pop();\r\n          oper2 = pilaCalc.pop();\r\n\r\n          //Caso operador \"*\"\r\n\r\n          if (par.cad === \"*\") {\r\n            if (oper1.isFraccion && oper2.isFraccion) {\r\n              pilaCalc.push(\r\n                InfijaAPolaca.operaBinFraccion(oper1, oper2, par.cad)\r\n              );\r\n            } else if (oper1.isFraccion) {\r\n              let resul = oper2.multiesc(oper1);\r\n              if (resul.isFraccion) {\r\n                pilaCalc.push(resul.ti); // el coef de x es cero guarda solo la fraccion\r\n              } else {\r\n                pilaCalc.push(resul);\r\n              }\r\n            } else if (oper2.isFraccion) {\r\n              let resul = oper1.multiesc(oper2);\r\n              if (resul.isFraccion) {\r\n                pilaCalc.push(resul.ti); // el coef de x es cero guarda solo la fraccion\r\n              } else {\r\n                pilaCalc.push(resul);\r\n              }\r\n            } else {\r\n              this.numError = -23; // error el resultado de la operación no es un termino lineal\r\n              return undefined;\r\n            }\r\n          }\r\n\r\n          //Caso operador \"/\"\r\n          else {\r\n            if (oper1.isFraccion && oper2.isFraccion) {\r\n              let resul = InfijaAPolaca.operaBinFraccion(oper1, oper2, par.cad);\r\n              if (resul.isFraccion) {\r\n                pilaCalc.push(resul);\r\n              } else {\r\n                this.numError = -24; // error: división entre cero. no es un número\r\n                return undefined;\r\n              }\r\n            } else if (oper1.isFraccion) {\r\n              oper1 = oper1.reciproco();\r\n              if (oper1.isFraccion) {\r\n                pilaCalc.push(oper2.multiesc(oper1));\r\n              } else {\r\n                this.numError = -24; // error: división entre cero. no es un número\r\n                return undefined;\r\n              }\r\n            } else if (oper2.isFraccion) {\r\n              this.numError = -23; // error el resultado de la operación no es un termino lineal\r\n              return undefined;\r\n            } else {\r\n              if (oper1.isMultiplo(oper2)) {\r\n                pilaCalc.push(oper2.cx.cociente(oper1.cx));\r\n              } else {\r\n                this.numError = -23; // error el resultado de la operación no es un termino lineal\r\n                return undefined;\r\n              }\r\n            }\r\n          }\r\n\r\n          break;\r\n\r\n        case 7: // operador menos unario\r\n          if (pilaCalc.length === 0) {\r\n            this.numError = -20; // error: se perdio un operando\r\n            return undefined;\r\n          }\r\n          oper1 = pilaCalc.pop();\r\n          if (oper1.isFraccion) {\r\n            pilaCalc.push(oper1.invAd());\r\n          } else if (oper1.isLineal) {\r\n            pilaCalc.push(new Lineal(oper1.cx.invAd(), oper1.invAd()));\r\n          }\r\n          //\r\n          break;\r\n        case 10: // número\r\n          numero = Number.parseFloat(par.cad);\r\n          if (Number.isNaN(numero)) {\r\n            pilaCalc.push(new Lineal(new Fraccion(1, 1), new Fraccion(0, 1)));\r\n          } else {\r\n            let numInt = Number.parseInt(par.cad);\r\n            if (numInt === numero) {\r\n              pilaCalc.push(new Fraccion(numInt));\r\n            } else {\r\n              pilaCalc.push(new Fraccion(numero, true));\r\n            }\r\n          }\r\n          break;\r\n        default:\r\n          break;\r\n      }\r\n    }\r\n    if (pilaCalc.length > 1) {\r\n      this.numError = -21; // error: sobraron operandos al evaluar!!!\r\n      return undefined;\r\n    }\r\n    this.numError = 0;\r\n    return pilaCalc.pop();\r\n  }\r\n\r\n  // calcula las operaciones algebraicas binarias\r\n  // opndo1 y opndo2 estan en el orden de salida del stack\r\n  // por eso se operan en orden inverso cuando no es simétrica la operación\r\n  static operaBin(opndo1, opndo2, operador) {\r\n    switch (operador) {\r\n      case \"+\":\r\n        return opndo2 + opndo1;\r\n      case \"-\":\r\n        return opndo2 - opndo1;\r\n      case \"*\":\r\n        return opndo2 * opndo1;\r\n      case \"/\":\r\n        return opndo2 / opndo1;\r\n      case \"^\":\r\n        return opndo2 ** opndo1;\r\n      default:\r\n        return 0; // es un operador inválido, a este nivel no pasa esto\r\n    }\r\n  }\r\n\r\n  // calcula las operaciones aritméticas binarias como fraccion\r\n  // opndo1 y opndo2 estan en el orden de salida del stack\r\n  // por eso se operan en orden inverso cuando no es simétrica la operación\r\n  static operaBinFraccion(opndo1, opndo2, operador) {\r\n    switch (operador) {\r\n      case \"+\":\r\n        return opndo2.suma(opndo1).reduce();\r\n      case \"-\":\r\n        return opndo2.resta(opndo1).reduce();\r\n      case \"*\":\r\n        return opndo2.producto(opndo1).reduce();\r\n      case \"/\":\r\n        return opndo2.cociente(opndo1).reduce();\r\n      // case '^':\r\n      // se supone que el exponente es un entero\r\n      // return opndo2.potencia(opndo1.n);\r\n      default:\r\n        return 0; // es un operador inválido, a este nivel no pasa esto\r\n    }\r\n  }\r\n\r\n  static IniciaErrores() {\r\n    InfijaAPolaca.errores[0] = \"\";\r\n    InfijaAPolaca.errores[1] = \"Hay un caracter inválido.\";\r\n    InfijaAPolaca.errores[2] = \"No hay expresión a procesar.\";\r\n    InfijaAPolaca.errores[3] =\r\n      \"Un separador(punto) decimal, signado o no, no representa un número.\";\r\n    InfijaAPolaca.errores[4] =\r\n      \"Un número no puede tener dos separadores(puntos) decimales.\";\r\n    InfijaAPolaca.errores[5] =\r\n      \"Es un número pero sólo se puede representar por +/- infinito internamente.\";\r\n    InfijaAPolaca.errores[6] = \"Hay dos operandos seguidos, falta un operador.\";\r\n    InfijaAPolaca.errores[7] =\r\n      \"Hay dos operadores seguidos, falta un número, una variable o una función.\";\r\n    InfijaAPolaca.errores[8] = \"La expresión tiene paréntesis derechos de más\";\r\n    InfijaAPolaca.errores[9] =\r\n      \"Falta un operador antes del parentesis izquierdo.\";\r\n    InfijaAPolaca.errores[10] = \"Falta un operando (número o variable).\";\r\n    InfijaAPolaca.errores[11] = \"Faltan paréntesis derechos.\";\r\n    InfijaAPolaca.errores[12] =\r\n      \"El argumento de una función debe ir entre paréntesis\";\r\n    InfijaAPolaca.errores[13] = \"Sólo se aceptan variables de una letra.\";\r\n    InfijaAPolaca.errores[14] =\r\n      \"Después de una variable no acepto un número. Indica la operación explícitamente.\";\r\n    InfijaAPolaca.errores[15] =\r\n      \"Las variables sólo pueden consistir de una letra opcionalmente seguida de dígitos.\";\r\n    InfijaAPolaca.errores[16] =\r\n      \"Ocurrio un error inesperado al identificar una variable!!!\";\r\n    InfijaAPolaca.errores[17] =\r\n      'No acepto parámetros o más de una variable, denotada por la letra \"x\".';\r\n    InfijaAPolaca.errores[18] = 'Sólo acepto la variable \"x\".';\r\n    InfijaAPolaca.errores[19] = \"\";\r\n    InfijaAPolaca.errores[20] = \"Se perdió un operando\";\r\n    InfijaAPolaca.errores[21] = \"Sobraron operandos al evaluar\";\r\n    InfijaAPolaca.errores[22] = \"Esperaba un número entero\";\r\n    InfijaAPolaca.errores[23] =\r\n      \"El resultado de la operación no es un término lineal\";\r\n    InfijaAPolaca.errores[24] =\r\n      \"División entre cero. el resultado no es un número\";\r\n    InfijaAPolaca.errores[25] =\r\n      'Falta el signo igual \"=\" para que sea una ecuación';\r\n    InfijaAPolaca.errores[26] = \"Debe haber una expresión antes del signo =\";\r\n    InfijaAPolaca.errores[27] = \"Debe haber una expresión después del signo =\";\r\n    InfijaAPolaca.errores[28] =\r\n      \"NO puede haber más de un igual en una ecuación\";\r\n  }\r\n}\r\n\r\n// Extiende String para identificar si una cadena con un caracter es un Dígito\r\nString.prototype.isDigit = function () {\r\n  return this.length === 1 && /^\\d/.test(this);\r\n};\r\n\r\n// Extiende String para identificar si una cadena con un caracter es una letra\r\nString.prototype.isLetter = function () {\r\n  return this.length === 1 && /^[A-Za-z]/.test(this);\r\n};\r\n\r\nexport default InfijaAPolaca;\r\n"]},"metadata":{},"sourceType":"module"}